# Pebblebed

![Pebblebed Logo - a very literal interpretation](https://github.com/lostpebble/pebblebed/raw/master/pebblebed.png "a very literal interpretation")

### A simple interface for interacting with the Google Cloud Datastore
Using NodeJS and on top of Google's official [`@google-cloud/datastore`](https://github.com/GoogleCloudPlatform/google-cloud-node#cloud-datastore-ga) library.

#### Prerequisites

* Google Cloud Datastore client. See [here](https://github.com/GoogleCloudPlatform/google-cloud-node#cloud-datastore-ga) for steps on activating your own Datastore client
* NodeJS **v7.6.0** _( async / await support )_
* Promises
* ( _optional_ ) Typescript for auto-complete goodness

#### Only one (peer) dependency

* `@google-cloud/datastore`

## Getting Started

##### Install the `pebblebed` package in your project:
```
yarn add pebblebed
```
or
```
npm install --save pebblebed
```

##### :electric_plug: Connecting client to Pebblebed

```
// Using example from Datastore documentation

import * as datastore from "@google-cloud/datastore";
import { Pebblebed } from "pebblebed"

const datastoreClient = datastore({
  projectId: 'grape-spaceship-123'
});

Pebblebed.connectDatastore(datastoreClient);
```

##### _And you're all set!_

###### Running Datastore locally for development
By default, the above sets up the Datastore Client to connect to your datastore in the cloud. But you can also run a datastore instance locally using the `gcloud` command line tool, specifically:

`gcloud beta emulators datastore start`

You just need to include the created local endpoint (it will show when you start the local datastore emulator) to your configuration like so:
```
const datastoreClient = datastore({
  projectId: 'grape-spaceship-123',
  apiEndpoint: "http://localhost:8081"
});
```

#### Next steps

* :scroll: Create a schema for an entity
* :hammer: Generate a model from that schema
* :blossom: Save, Load or Query on that entity

## Creating an Entity schema

Inspired by another Datastore library (gstore-node), we need to create schemas to let Pebblebed know how our entities are structured. Because JavaScript is weakly typed, this ensures that we make no mistakes about what we intend to save / load / query.

A **schema definition** consists of an object of property names and definitions for each of those properties, conforming to this interface:

```
interface SchemaDefinition {
  [property: string]: SchemaPropertyDefinition;
}
```

And the **schema property definition** interface:

```
interface SchemaPropertyDefinition {
  type: "string" | "int" | "double" | "boolean" | "datetime" | "array" | "object" | "geoPoint";
  required?: boolean;
  role?: "id";
  excludeFromIndexes?: boolean;
  optional?: boolean;
  onSave?: (value: any) => any;
  default?: any;
}
```

Schemas are contracts between your JavaScript objects and the eventual stored objects in the datastore. In that sense, you need to pay close attention to how you define each property in the schema. Let's go over the options for each property on the schema:

#### `type` : The type of the value to be stored in the datastore for this property

Our JavaScript entity objects can contain certain types which are converted by our schema on storage / retrieval from the Datastore:
  * `string`, `int`, `double`, `boolean`, `array` - self explanatory
  * `datetime` converted to / from JavaScript `Date` object
  * `object` for embedded JavaScript objects
  * `geoPoint` 
    * Will be automatically converted to / from an object with a structure of:
      * `{ latitude: number, longitude: number }`
    * Can be deliberately set to datastore type `geoPoint` using the client library before save if you want



#### `role` : Define which property is our entity `id` (see next)

### :key: Entity ID

There can only be one property on the schema definition that is defined with `role: "id"`. This property will represent the Entity's ID.

:warning: **N.B. This property is not persisted as an Entity property in the Datastore - it is only used as the ID**

When saving an entity to the datastore, it can have an id value type of either `string` or `int`.

* `int` IDs can be deliberately set or, if omitted, auto-generated by the datastore.
* `string` IDs must always be deliberately set.

* It will contain the string or integer ID of the entity whenever it is **loaded** or **queried**
* It should also be set to whatever ID you would like for the entity when you **save** it (or if it is an `int`, can be left unset to auto-generate an ID).

If there is no property in the schema definition which has a `role: "id"` set, then the ID will be auto-generated on save. For ease of use and better control, **this is not recommended though** (even if all your ids are auto-generated).

### An example schema definition might look like this:
```
const schemaDefinition = {
    testID: {
        type: "string",
        role: "id",
    },
    testAmount: {
        type: "double",
    },
    testTags: {
        type: "array",
        required: true,
    },
    testEmbeddedObject: {
        type: "object",
        required: true,
        excludeFromIndexes: true,
    },
    testDate: {
        type: "datetime",
        required: true,
    },
};
```

This defines an entity with a `string` ID on property `testId`, 

Along with four properties to be persisted in the datastore:
* `testAmount` _(optional)_
* `testTags`
* `testEmbeddedObject`
* `testDate`

## Create an Entity Model

Entity Models are used to do all our interactions with the Datastore. They are created using the structure defined in your schema and allow operations on your Entities such as load, save or query.

They are very simply created like so:

```
import { PebblebedModel } from "pebblebed";

const TestEntityModel = new PebblebedModel("TestEntity", schemaDefinition);
```

In this example, `TestEntity` will be the entity's kind in the Datastore

After which, you can now use that model to perform operations like so (**save** operation for example):

```
const entity = {
  testID: "test-id-one",
  testTags: ["Great", "Again"],
  testEmbeddedObject: {
    who: "let the dogs out",
  },
  testDate: new Date(),
  testAmount: 123.123,
};

await TestEntityModel.save(entity).run();
```

This will validate and convert all the entity data from the JavaScript object according to our schema, and save the entity in the Datastore as a `TestEntity` kind with the id `test-id-one`, it would end up like this in your Cloud Datastore Console:

![Google Cloud Console view](https://github.com/lostpebble/pebblebed/raw/master/resources/entity-save-console.jpg "Google Cloud Console view")

**Note that the `testID` property has been used as the ID, and NOT persisted as a property**

This entity can later be retrieved from the Datastore using a **query** or a **load** operation, like so:

```
const query = await TestEntityModel.query().filter("testTags", "=", "Great").run();
const entity = await TestEntityModel.load("test-id-one").run();

console.dir(JSON.stringify(query.entities));
console.dir(JSON.stringify(entity));
```

Both of those `console.dir` outputs will show the following (neatened up a bit):
```
[
  {
    "testDate": "2017-06-07T15:52:14.109Z",
    "testEmbeddedObject": {"who":"let the dogs out"},
    "testTags": ["Great","Again"],
    "testAmount":123.123,
    "testID":"test-id-one"
  }
]
```

In this example, an array with a single element.

All load or query operations will return an array in this way to represent results. An empty array indicates no results. The property `testDate` is an actual JavaScript `Date` object, but in our `console.dir()` has been converted to a string by `JSON.stringify()`.

## Full example

```
import { PebblebedModel } from "pebblebed";

// Create a schema for an entity

const schemaDefinition = {
    testID: {
        type: "string",
        role: "id",
    },
    testAmount: {
        type: "double",
    },
    testTags: {
        type: "array",
        required: true,
    },
    testEmbeddedObject: {
        type: "object",
        required: true,
        excludeFromIndexes: true,
    },
    testDate: {
        type: "datetime",
        required: true,
    },
};

// Create the model for our entity, of kind "TestEntity"

const TestEntityModel = new PebblebedModel("TestEntity", schemaDefinition);

// Create a new entity and save it

const entity = {
  testID: "test-id-one",
  testTags: ["Great", "Again"],
  testEmbeddedObject: {
    who: "let the dogs out",
  },
  testDate: new Date(),
  testAmount: 123.123,
};

await TestEntityModel.save(entity).run();
```

###### _After some time_

```
// Query for our entity by tag
const query = await TestEntityModel.query().filter("testTags", "=", "Great").run();

// Or load our entity directly with its string ID
const entity = await TestEntityModel.load("test-id-one").run();

// ...do work on entity...
entity.testAmount = 35.50;

// save it again
await TestEntityModel.save(entity).run();
```

###### _After some time_

```
// Delete the unwanted entity
await TestEntityModel.delete().id("test-id-one").run();
```

## Full library interface

